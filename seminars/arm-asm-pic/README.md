# Программирование на языке ассемблера ARM

## Позиционно-независимый код

Программа называется позиционно-независимой, если ее код (точнее, сегмент кода `.text`) не зависит от адреса,
по которому он загружается в виртуальное адресное пространство.

Все сегменты программы (`.text`, `.data` и т. д.) рассматриваются как одно целое, и относительное расположение
сегментов программы не изменяется при изменении адреса загрузки программы, то есть, условно говоря,
программа переносится с одного базового адреса на другой базовый адрес целиком.

Если программа позиционно-независима, то по какому бы то ни было базовому адресу программа не размещалась,
секция кода (`.text`) будет идентична, и, с учетом того, что секция кода не доступна на запись,
во всех процессах можно отображать виртуальные страницы, занимаемые кодом, на одни и те же страницы физической
памяти. Это особенно важно для динамических библиотек.

Динамические библиотеки (.so файлы) загружаются в адресное простанство каждого процесса, который их использует,
но, при этом, в каждом процессе одна и та же динамическая библиотека может быть загружена по своему
базовому адресу, отличающемуся от базового адреса этой библиотеки в других процессах. Страницы кода динамической
библиотеки разделяются между всеми процессами, если код динамической библиотеки позиционно-независимый.
Таким образом достигается большая экономия оперативной памяти.

Например, код стандартной библиотеки языка Си (libc.so) занимает в памяти каждого процесса около 2 мегабайт.
Если в системе одновременно работает 200 процессов, и каждый процесс подгружает в свое адресное пространство
стандартную библиотеку языка Си, то экономия физической оперативной памяти из-за того, что все процессы используют
общие физические страницы для кода стандартной библиотеки, составит примерно 400 мегабайт.

## GOT (Global Offset Table)

В случае, если позиционно-независимая программа использует глобальные переменные, особенно переменные из других
единиц компиляции или даже из других динамически загружаемых библиотек, или когда вызываются функции из
других динамических библиотек, необходимо знать абсолютный адрес, по которому переменная или подпрограмма
размещается в виртуальном адресном пространстве. Для связывания динамически-загружаемых модулей используется
GOT.

GOT размещается в отдельной секции исполняемого файла (`.got`). Эта секция доступна на чтение и запись.
При загрузке в виртуальное адресное пространство динамический загрузчик записывает в секцию `.got` виртуальные
адреса глобальных переменных и процедур. В каждом процессе секция GOT может отличаться от секции GOT в других
процессах. Поэтому секция GOT не будет разделяться между процессами, но размер секции GOT намного меньше,
чем размер основной секции кода.

После того, как разделяемая библиотека загружена в память и таблица GOT обработана динамическим загрузчиком,
таблица GOT представляет собой массив виртуальных адресов. Первые несколько адресов - служебные,
в них содержится, в частности, точка входа в подпрограмму динамического связывания динамического загрузчика.

Получить адрес начала GOT в позиционно-независимой программе можно следующим образом:

```
        .text
        // ...
        ldr     r0, gotaddr
L1:     add     r0, r0, pc
        // ...

gotaddr:.word   _GLOBAL_OFFSET_TABLE_ - L1 - 8
```

Метка `_GLOBAL_OFFSET_TABLE_` помечает начало таблицы GOT. В ячейке `gotaddr` хранится смещение от точки в секции кода,
помеченной `L1`, до начала GOT. В строке, помеченной `L1` в регистре `r0` будет вычислен абсолютный адрес
начала таблицы GOT. Важно, чтобы ячейка `gotaddr` находилась в сегменте кода `.text`.

Для вычисления адреса глобальной переменной необходимо знать смещение, по которому располагается абсолютный адрес
глобальной переменной, в таблице GOT. Если глобальная переменная называется `globvar`, то смещение этой переменной
относительно начала GOT можно поместить в ячейку памяти следующим образом:

```
globoff:.word   globvar(GOT)
```

Важно, чтобы `globoff` находилась в сегменте кода `.text`.

Теперь, чтобы вычислить абсолютный адрес глобальной переменной `globvar` нужно вычислить адрес начала
таблицы GOT, и загрузить ячейку со смещением, хранящимся в `globoff`, относительно начала GOT.
Это будет адрес глобальной переменной. Его можно использовать и для чтения из памяти, и для записи в память.

Фрагмент программы может выглядеть следующим образом:

```
        .text
        // ...
        ldr     r0, gotaddr
L1:     add     r0, r0, pc
        ldr     r1, globoff
        ldr     r1, [r0, r1]   // в регистре `r1` будет адрес глобальной переменной `globvar`
        // ...

gotaddr:.word   _GLOBAL_OFFSET_TABLE_ - L1 - 8
globoff:.word   globvar(GOT)
```
