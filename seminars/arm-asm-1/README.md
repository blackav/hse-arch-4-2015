# Программирование на языке ассемблера ARM

## Инструментальные средства

Программы на языке ассемблера будут транслироваться с помощью GCC.
Исходный код программы должен находиться в файле `prog.s` или `prog.S`.
Файл с суффиксом `.S` перед трансляцией обрабатывается препроцессором языка Си.

Для трансляции программы в исполняемый код можно использовать команду:
```
gcc prog.s -o prog
```

При компоновке программы к ней будут прилинкованы файл начальной инициализации
и стандартная библиотека языка Си. Точка входа в программу на языке ассемблера
в этом случае будет такая же, как и в случае языка Си - `main`.

Также можно использовать функции стандартной библиотеки языка Си,
например, `scanf` или `printf`.

## Структура файла программы

Комментарии в файле записываются в стиле языка Си, то есть либо
```
 // комментарий до конца строки
```

или

```
/*
блочный комментарий
*/
```

Программа на языке ассемблера состоит из последовательности инструкций процессора
и директив ассемблера. Каждая инструкция или директива ассемблера занимает одну строку текста.

Программа на ассемблере состоит из нескольких секций. Основные секции следующие:

Секция `.text` содержит машинный код программы (инструкции процессора). Кроме этого
в эту секцию могут помещаться константные данные (таблицы переходов, таблицы виртуальных
функций, строки). Поэтому нельзя сказать, что каждая ячейка памяти в секции `.text`
содержит инструкцию процессора. При выполнении программы секция `.text` доступна только
на чтение и выполнение. Модифицировать память нельзя - программа будет завершена с
ошибкой обращения к памяти.

Секция `.data` содержит глобальные переменные. При выполнении программы секция `.data`
доступна на чтение и запись, но не на выполнение.

Секция `.bss` содержит глобальные переменные, место под которые зарезервировано,
но сами переменные будут проинициализированы нулями при запуске программы на выполнение.
Секция `.bss` не занимает места в исполняемом файле программы, в отличие от секции `.data`.

По умолчанию, компилятор языка Си помещает в `.bss` глобальные переменные, которые не были
инициализированы явно. Например, массив

```
char arr1[1024*1024];
```
будет помещен компилятором Си в секцию `.bss`, и поэтому не будет занимать место в исполняемой
программе, а массив

```
char arr1[1024*1024] = { 0 };
```
будет помещен компилятором в секцию `.data`, что отразится на размере сгенерированного исполняемого файла.

В файле исходного кода секции могут быть перемешаны в произвольном порядке. Ассемблер разместит все фрагменты исходного
кода, относящиеся к одной секции, в памяти последовательно. Например,

```
        .text
        .int    1
        .data
        .int    2
        .text
        .int    3
        .data
        .int    4
```

Сначала в памяти будет размещена вся секция `.text`, а в ней последовательно будут размещены директивы
```
        .int    1
        .int    3
```

Затем в памяти будет размещена вся секция `.data`.

Когда исполняемый файл компонуется из нескольких объектных модулей, компоновщик ld также выполняет слияние
одноименных секций из всех объектных файлов, поданных ему на вход, в одну секцию в исполняемом файле.
То есть все секции `.text` в объектных файлах будут слиты и помещены в одну секцию `.text` в исполняемом файле,
и аналогично с другими секциями.

## Метки

Метка --- это символическая запись адреса в памяти или константы. Помеченной может быть и инструкция процессора, и директива ассемблера.
При определении метки после ее имени записывается символ двоеточия.
Например,

```
var1:   .int    100
```

Метка `var1` обозначает адрес в памяти, по которому при работе программы будет размещаться данная ячейка памяти. Обратите внимание,
что этот адрес станет окончательно известным только на этапе компоновки программы. Объектный файл, передаваемый на вход компоновщику,
содержит специальные записи перемещения для настройки всех использований метки `var1` на корректные адреса в памяти.

Метка может обозначать некоторую константу, например,

```
size    =       500
```

В этом случае метка `size` имеет значение 500. Метка имеет константное значение и может использоваться везде в программе
в качестве замены значению 500.

В любом случае, метка --- это символическая запись константного выражения. Значение метки должно быть известно на момент запуска программы
на выполнение.

## Директивы ассемблера

### Организация программы в секции

Для разбиения программы по секциям используются директивы `.text`, `.data`, `.bss`.

### Атрибуты меток

По умолчанию метки имеют статическую область видимости, то есть видны от точки определения и до конца файла.
Чтобы значение метки было доступно из других объектных файлов, необходимо явно объявить метки глобальными.

```
        .global main
main:
```

Метка `main` будет объявлена глобальной и будет доступна из других объектных файлов при компоновке программы.

### Определение данных

Директивы `.byte`, `.short`, `.hword`, `.int`, `.long`, `.word`, `.qword` позволяют зарезервировать ячейки данных
соответствующего размера. Размер зависит от платформы, например, для ARM `.byte` - это один байт, `.short`, `.hword` -
это два байта, `.int`, `.word`, `.long` - это 4 байта, `.qword` - это 8 байт.

Можно резервировать сразу несколько ячеек, например,
```
        .int    1, 2, 3
```

зарезервирует 3 32-битных ячейки с начальными значениеми 1, 2, 3.

Директивы `.float`, `.double` позволяют зарезервировать ячейки и проинициализировать их вещественными значениями
типа `float` и `double` соответственно. На платформе ARM `float` имеет размер 4 байта, а `double` - 8 байт.

Директивы `.ascii` и `.asciz` позволяют резервировать память под строки.

```
        .asciz  "Hello!"
```

Будет заререзвировано 7 байт, которые будут заполнены значениям соответствующих кодов символов.

Директива `.space` позволяет резервировать место заданного размера.
```
        .space  100, 10
```

резервирует 100 байт и заполняет их значением 10.

Директива `.align` позволяет выравнивать данные.
Например, после директивы
```
        .align  8
```
гарантируется, что следующая инструкция или директива определения данных разместится по адресу, кратному 8.

## Регистры процессора

В архитектуре ARM32 программисту доступны 16 32-битных регистров общего назначения. Они обозначаются `r0`, `r1`, `r2`, ... `r15`.
Из этих регистров три регистра имеют особенное предназначение: регистр `r15` (еще обозначается `pc`) --- содержит адрес
в памяти, из которого будет подгружатся очередная инструкция для исполнения;
регистр `r14` (еще обозначается `lr` (link register)) используется для вызова подпрограмм;
регистр `r13` (еще обозначается `sp`) используется для организации стека подпрограмм.

Регистры общего назначения используются для хранения часто используемых локальных переменных,
для хранения временных результатов при вычислении выражений,
как аргументы арифметических и логических операций
и как аргументы при вычислении адреса в инструкциях косвенной загрузки из памяти.

## Организация программы

Программа (исполняемый код программы) на языке ассемблера представляет собой совокупность подпрограмм.
Подпрограммы в ассемблере являются аналогом функций языка Си.
Подпрограммы могут принимать значения и возвращать результат.
Какой именно способ используется для передачи параметров в подпрограмму и возврата результата из
подпрограммы описывается соглашениями о вызовах (calling convention).

Для ARM стандартное соглашение о вызовах следующее:

* Используется full-descending стек, то есть при занесении в стек значение регистра `sp`
уменьшается, регистр `sp` указывает на первое занятое значение в стеке.
* При вызове подпрограмм значение указателя стека должно быть выровнено по 8 байтам.
Поэтому, общий размер параметров, передаваемых через стек должен быть кратен 8 байтам.
Общий размер локальных переменных и сохраненных регистров в стеке также должен быть
кратен 8 байтам.
* Параметры в подпрограмму передаются в регистрах `r0`, ..., `r3` и далее в стеке.
Параметры заносятся в стек в обратном порядке, то есть параметр с меньшим номером
находится в памяти по меньшим адресам.
* Переменная часть параметров (обозначаемая в Си `...`) всегда передается на стеке.
* Значения типов `long long` и `double` должны быть выровнены по 8 байтам. Все остальные значения
выравниваются по 4 байтам (даже `char`).
* При передаче параметров в регистрах значения типов `long long` и `double` могут размещаться
только в паре регистров `r0`, `r1` или `r2`, `r3`. В регистре с меньшим номером размещается
младшая половина значения. Это может приводить к тому, что регистр `r1` не будет использоваться.
* Подпрограммы должны сохранять значения регистров `r4` ... `r11`. То есть вызывающая подпрограмма
может расчитывать на то, что после возврата из подпрограммы значения регистров `r4`, ... `r11`
сохранятся.
* Регистры `r0` ... `r3`, `r12`, `r14` (`lr`) могут произвольным образом меняться.
* При входе в подпрограмму адрес возврата в вызывающую подпрограмму находится в регистр `lr`.
Сама подпрограмма должна сохранить адрес возврата (например, в стек), если будут
вызываться вложенные подпрограммы.
* Результат работы подпрограммы возвращается в регистрах `r0` ... `r3`. То есть, если результат имеет размер
не более 4 байт, он возвращается в `r0`. Если результат имеет размер 8 байт, он возвращается в регистрах
`r0` и `r1`. Если результат имеет размер более 16 байт, возврат значения должен выполняться другими средствами.

С точки зрения организации подпрограммы типичная подпрограмма должна при входе сохранить регистр `lr`
и те регистры `r4` ... `r11`, которые будут изменяться в подпрограмме. При этом количество регистров должно быть
четным. При выходе из подпрограммы все сохраненные регистры нужно восстановить. При этом вместо восстановления
регистра `lr` можно сразу восстанавливать регистр `pc`.

Типичный пролог подпрограммы может выглядеть следующим образом:
```
        stmfd   sp!, { r4, r5, r6, lr } // сохранение регистров в стек
```

Эпилог подпрограммы будет выглядеть следующим образом:
```
        ldmfd   sp!, { r4, r5, r6, pc } // восстановление регистров и возврат из подпрограммы
```

Для вызова другой подпрограммы нужно подготовить аргументы на регистрах `r0` ... `r3` и на стеке,
если необходимо, и выполнить инструкцию `bl` (branch with link). Например,

```
        mov     r0, #1 // загружаем в r0 значение 1
        bl      exit   // вызываем функцию exit стандартной библиотеки Си
```

## Инструкции пересылки данных

Для пересылки данных между регистрами можно использовать инструкцию `mov`.

```
        mov     r0, r4 // переслать в r0 значение, хранящееся в r4
```

Загрузка константы на регистр тоже выполняется с помощью команды `mov`.

```
        mov     r0, #0xff // загрузить в r0 значение 0xff
```

Но таким образом можно загрузить на регистр не все возможные 32-битные значения. Инструкция загрузки значения в регистр
занимает в памяти 4 байта (как и любая другая инструкция), и под загружаемое значение в записи инструкции в памяти отводится
меньше чем 32 бита. Чтобы загрузить произвольное значение на регистр нужно поместить это значение в память в той же
секции, в которой находится инструкция загрузки. Например,

```
        ldr     r0, babeval
        ...
babeval:
        .word   0xbabe
```

Важно, чтобы процессор никогда не пытался выполнить значение по адресу `babeval` как инструкцию, то есть на нее
никогда не должно попадать управление. Для этого где-то раньше `babeval` должна находится инструкция, которая
всегда передает управление в другую точку, например, безусловный переход или возврат из подпрограммы.

Ячейка памяти, помеченная `babeval`, обязательно должна находиться в той же секции (обычно `.text`), что и инструкция
`ldr`.

На самом деле, для загрузки в регистр `r0` значения по адресу `babeval` применяется метод адресации относительно `pc`.
Поддерживаемые архитектурой ARM методы адресации будут рассмотрены позднее.

Для загрузки на регистр значения из памяти применяется инструкция `ldr`, а для сохранения значения в память ---
инструкция `str`. Эти инструкции манипулируют со словом (32 бита).

## Пример

В данном примере на стандартный поток вывода выводится строка Hello!.

```
        .text
        .global main
        .align  4               // выравниваем текущий адрес
main:
        stmfd   sp!, { r4, lr } // сохраняем два регистра в стек
        ldr     r0, ahell       // загружаем в r0 значение из ячейки ahell (см. ниже)
        bl      puts            // вызываем функцию puts стандартной библиотеки Си
        mov     r0, #0          // загружаем значение 0 в регистр r0
        ldmfd   sp!, { r4, pc } // возврат из подпрограммы, как return в main в программе на Си
ahell:  .int    hellos          // здесь находится адрес строки "Hello!", ahell должна находится в секции .text
        .data
hellos: .asciz  "Hello!"        // байт \0 будет добавлен автоматически
```

В данном примере строку "Hello!" можно разместить непосредственно в секции кода. Но тогда для получения
ее адреса потребуется использовать регистр `pc`.

```
        .text
        .global main
        .align  4               // выравниваем текущий адрес
main:
        stmfd   sp!, { r4, lr } // сохраняем два регистра в стек
        add     r0, pc, #hellos - . - 8 // см. ниже
        bl      puts            // вызываем функцию puts стандартной библиотеки Си
        mov     r0, #0          // загружаем значение 0 в регистр r0
        ldmfd   sp!, { r4, pc } // возврат из подпрограммы, как return из main в программе на Си
hellos: .asciz  "Hello!"        // байт \0 будет добавлен автоматически
```

Разберем подробнее инструкцию
```
        add     r0, pc, #hellos - . - 8
```

Эта инструкция прибавляет к значению регистра `pc` некоторую константу и заносит результат в регистр `r0`.
В выражении для прибавляемой константе символ "точка" (.) обозначает адрес текущей инструкции.
Тогда выражение `hellos - .` - это смещение, которое нужно прибавить к адресу текущей инструкции, чтобы
получить адрес в памяти, по которому располагается строка `hellos`. Из этого выражения
вычитается "магическое" число 8, так как по историческим причинам на архитектуре ARM в режиме кодирования
инструкций ARM значение регистра `pc` при чтении из него на 8 больше адреса текущей инструкции.

## Передача данных в подпрограммы через стек

Если параметры, передаваемые в подпрограмму, перестают помещаться в первые четыре регистра,
для передачи части параметров используется стек.

При передаче параметров нужно учитывать следующее:
* общий размер параметров, помещенных в стек, должен быть кратен 8, если параметров не хватает, необходимо
поместить неиспользуемое значение для выравнивания;
* параметры помещаются в обратном порядке, так что в стеке параметры будут находиться в прямом порядке,
то есть параметр, идущий раньше в списке параметров, будет размещаться по меньшим адресам;
* параметры, размер которых меньше машинного слова (4 байта) занимают одно машинное слово;
* параметры типа `long long` и `double` должны быть выровнены по 8 байтам.

После возврата из выбранной функции стек должен быть очищен, то есть все помещенные в стек аргументы с него
удалены, самой подпрограммой.

## Ввод-вывод с использованием библиотеки libc

Для вывода на стандартный поток вывода можно использовать функции стандартной библиотеки Си `printf`, `fputs`, `putc`
и т. п. Для ввода со стандартного потока ввода можно использовать функции стандартной библиотеки `scanf`, `fgets`, `getc`.
Работа с функциями с переменным числом параметров не отличается от работы с обычными функциями, то есть первый аргументы
функции передаются через регистры `r0` ... `r3`, а оставшиеся через стек.

В следующем примере на стандартный поток вывода будет напечатано текущее время
(в Unix-представлении, то есть как число секунд с 1970-01-01 00:00:00).

```
        .text
        .global main
main:   stmfd   sp!, { r4, lr }
        sub     r0, r0, r0           // обнуляем регистр r0
        bl      time                 // вызываем time, вызов time(NULL)
        mov     r1, r0               // пересылаем r0 в r1
        add     r0, pc, #fmt - . - 8
        bl      printf
        mov     r0, #0
        ldmfd   sp!, { r4, pc }
fmt:    .asciz  "Time: %d\n"
```

Аналогично можно вызывать и функцию `scanf`, только обратите внимание, что в стек нужно будет заносить адрес переменной в памяти.

В следующем примере значение типа `int`, считанное функцией `scanf` будет помещено в глобальную переменую.

```
        .text
        .global main
main:   stmfd   sp!, { r4, lr }
        ldr     r1, pvar              // загружаем в r1 значение из ячейки pvar (то есть адрес переменной var)
        add     r0, pc, #sfmt - . - 8 // грузим в r0 адрес форматной строки
        bl      scanf
        ldr     r0, pvar              // загружаем в r0 адрес переменной var
        ldr     r0, [r0]              // загружаем в r0 значение по адресу r0
        ldmfd   sp!, { r4, pc }
pvar:   .int    var                   // здесь находится адрес глобальной переменной var
sfmt:   .asciz  "%d"
        .data
var:    .int    0
```

Альтернативно мы можем размещать переменную для использования функцией `scanf` не в глобальной области данных, а на стеке.
При входе в подпрограмму мы выделим область в стеке требуемого размера, а при завершении подпрограммы ее уничтожим.
Размер области стека должен быть кратен 8 байтам.

```
        .text
        .global main
main:   stmfd   sp!, { r4, lr }
        sub     sp, sp, #8            // выделяем 8 байт под локальные переменные
        mov     r1, sp                // копируем текущее значение sp (то есть адрес локальной переменной) в r1
        add     r0, pc, #sfmt - . - 8
        bl      scanf
        ldr     r0, [sp]              // загружаем в r0 значение, находящееся на верхушке стека
        add     sp, sp, #8            // уничтожаем область локальных переменных
        ldmfd   sp!, { r4, pc }
sfmt:   .asciz  "%d"
```

## Арифметические и логические операции

Арифметические и логические операции перечислены ниже.

```
        add     dst, src1, src2         // dst = src1 + src2            // сложение
        adc     dst, src1, src2         // dst = src1 + src2 + CF       // сложение с переносом
        sub     dst, src1, src2         // dst = src1 - src2            // вычитание
        sbc     dst, src1, src2         // dst = src1 - src2 + CF - 1   // вычитание с заемом
        rsb     dst, src1, src2         // dst = src2 - src1            // вычитание
        rsc     dst, src1, src2         // dst = src2 - src1 + CF - 1   // вычитание с заемом

        and     dst, src1, src2         // dst = src1 & src2            // побитовое и
        eor     dst, src1, src2         // dst = src1 ^ src2            // исключающее или
        orr     dst, src1, src2         // dst = src1 | src2            // побитовое или
        bic     dst, src1, src2         // dst = src1 & ~src2           // очистка бит
```

Операции пересылки

```
        mov     dst, src                // dst = src
        mvn     dst, src                // dst = ~src
```

Операции сравнения и проверки значения

```
        cmp     src1, src2              // src1 - src2                  // флаги устанавливаются, результат не сохраняется
        cmn     src1, src2              // src1 + src2                  // флаги устанавливаются, результат не сохраняется
        tst     src1, src2              // src1 & src2                  // то же самое
        teq     src1, src2              // src1 ^ src2                  // то же самое
```

## Арифметические флаги результата

Регистр `cpsr` хранит четыре флага, которые могут устанавливаться в результате выполнения арифметических операций.
Это - флаги 'N', 'Z', 'C', 'V'.

* Флаг 'Z' равен 1, если результат операции равен 0
* Флаг 'N' равен 1, если у результата операции установлен старший бит, то есть результат операции отрицательный,
если интерпретировать его как знаковое число
* Флаг 'C' равен 1, если
** при операции сдвига в бит 'C' попала 1
** при сложении произошел перенос из 31 (старшего) бита в 32, то есть произошло переполнение разрядной сетки
беззнаковых чисел
** при вычитании произошел заем из 32 разряда, то есть произошло переполнение разрядкой сетки беззнаковых чисел
* Флаг 'V' равен 1, если при операции произошло переполнение разрядной сетки знаковых чисел

Операции сравнения и проверки результата всегда устанавливают четыре флага результата. Другие операции по умолчанию
не устанавливают флаги результата, но чтобы флаги устанавливались, к мнемонике инструкции приписывается 's'. Например,

```
        add     r0, r1, r2 // r0 = r1 + r2
        adds    r0, r1, r2 // r0 = r1 + r2 и в зависимости от результата будут установлены флаги Z, N, C, V
```
